/*
함수 객체는 함수처럼 호출 가능한 클래스 객체입니다.
함수 객체는 함수처럼 사용할 수 있으면서 상태를 가질 수 있기 때문에 STL은 함수보다 함수객체를 선호.
STL의 많은 알고리즘이 클라이언트 정책을 반영하기 위해 클라이언트 함수를 호출합니다.
STL은 조건 비교, 기본 연산 등 미리 정의된 여러 함수 객체를 제공합니다.

01 함수 객체란
Function Object는 함수처럼 동작하는 객체입니다.
함수처럼 동작하려면 객체가 '()'연산자를 정의해야합니다.
다시말해 '()'연산자를 오버로딩한 객체입니다.
함수 객체는 함수자(Functor)라고 불리기도 합니다.
3_1.cpp 함수 객체 정의

functor는 객체지만 함수(functor())처럼 호출할 수 있습니다.
'()'연산자 멤버 함수를 호출합니다.
매개 변수 리스트를 갖는 함수 객체를 만들 수 있습니다.
3_2.cpp 두 정수형 매개변수를 갖는 함수 객체
functor(10,20)은 실제 functor.operator()(10,20)처럼 멤버 함수를 호출합니다.

함수 객체의 장점
함수처럼 동작하는 객체이므로 다른 멤버 변수와 멤버 함수를 가질 수 있고 일반 함수에서 하지못하는 지원을 받을 수 있다.
함수 객체의 서명이 같더라도 객체 타입이 다르면 서로 전혀 다른 타입으로 인식합니다.
속도도 일반함수보다 함수 객체가 빠릅니다.
함수의 주소를 전달하여 콜백하는 경우 이 함수 포인터는 인라인될 수 없지만 함수 객체는 인라인될 수 있고,
컴파일러가 쉽게 최적화할 수 있습니다.
(함수 포인터는 함수가 있어야 하므로 인라인 함수의 복사본 함수를 만들어 냅니다)

내부적인 상태값을 갖는 함수 객체.
3_3.cpp 멤버 변수를 갖는 함수 객체
초기값 0을 시작으로 add()함수를 호출할 때마다 정수를 누적하고 반환합니다.
operator()(int n)함수는 클래스 내부에 정의되므로 암묵적으로 인라인 함수가 됩니다.
operator()(int n)와 서명이 같더라도 타입이 다른 함수 객체는 Adder 클래스 객체에 대입하거나 복사 불가능.

콜백함수 예제를 함수객체를 사용하여 변경
3_4.cpp 함수 객체를 사용한 콜백 함수 구현.
for_each()알고리즘의 세번째 인자에 함수가 아닌 함수 객체를 전달했습니다.
전달하는 함수 객체의 타입도 모두 다릅니다.
struct로 사용자 정의 타입 이고 미리 만들어 놓을 수 없는데 함수 오버로딩을 사용하지도 않았다.
for_each()알고리즘은 사용자 정의타입까지 전달받을 수 있는 이유는 템플릿이기 때문.

02 함수 객체 구현
STL에는 유용하게 사용할 수 있는 함수 객체가 내장돼 있습니다.
대표적인 함수 객체는 less와 greater입니다.
less는 <연산자의 함수 객체이며, greater는 >연산자의 함수 객체입니다.
또한 less와 greater는 bool형을 반환하는 조건자(predicate)입니다.
3_5.cpp Less의 구현
l(10,20)은 함수 객체로 두 정수를 받아 l.operator()(10,20)을 호출하고 결과를 반환합니다.
Less()(10,20)에서 Less()는 임시객체를 생성하고 Less().operator()(10,20)을 호출합니다.

STL의 less함수 객체
3_6.cpp STL의 less 함수 객체.
typedef를 사용한 이유는 less가 템플릿클래스이므로 짧고 쉬운 이름을 사용하기 위해.

3_7.cpp Greater의 구현
결과는 같고 STL less, greater는 템플릿 클래스이므로 임시객체를 less<int>(), greater<int>()와 같이 생성.
int는 비교할 값의 타입.

plus와 minus는 두 객체(정수)의 합과 차 연산의 함수 객체.
3_8.cpp plus와 minus 함수 객체 구현

*/
/*
연산자 오버로딩은 많은 STL구성요소에 사용돼 쉽고 더 직관적이며 일반화된 코드를 만들어 냅니다.

01 연산자 오버로딩이란
C++에서 제공하는 기본 타입이 아닌 클래스 타입, 사용자 정의 타입에도 연산자를 사용할 수 있게 하는 문법.
1_1.cpp 정수의 +연산
기본적으로 컴파일러에 연산이 정의되어 있기 때문에 가능하지만 사용자가 정의한 Point클래스의 연산을 불가능.
컴파일러 내부에 연산이 정의되어 있지 않기 때문.
1_2.cpp Point객체의 +연산
연산자 오버로딩을 사용하면 컴파일러 내부에 정의되지 않은 타입의 연산이 가능하여 코드의 직관성과 가독성을 좋게 한다.

02 연산자 오버로딩 정의 및 사용하기
연산자 오버로딩의 핵심은 클래스 타입의 객체에 연산자를 사용하면 컴파일러는 정의된 함수를 호출하는데 있다.
1_3.cpp 연산자 오버로딩 함수 호출
컴파일러는 주석에 쓴 것처럼 해석합니다.
p1 + p2는 p1.operator+(p2)라고 호출하므로 p1객체를 기준으로 멤버 함수 operator+()를 호출하고 인자로 p2를 전달.
operator+()가 정의되어 있으면 호출이 가능하고 없으면 컴파일러 에러.
1_4.cpp operator+() 함수 정의
p1의 x와 p2의 x를 더하고 p1의 y와 p2의 y를 더한다는 의미.
1_5.cpp operator+() 함수 구현
p1은 this객체이며 p2는 arg객체이다.
p1.operator+(p2)함수가 두 객체를 더한 객체를 반환해야 하므로 반환타입을 사용
1_6.cpp operator+() 함수 완성
연산자 오버로딩은 컴파일러와 약속된 함수를 이용해 사용자 정의 타입에 연산이 가능하도록 제공하는 것.

const멤버함수와 비 const멤버함수
const멤버함수는 멤버 함수 내에서 객체의 멤버 변수를 변경하지 않는다는 것을 보장하는 함수입니다.
따라서 const객체는 const멤버 함수만 호출할 수 있습니다.
const멤버 함수에서 멤버 변수를 변경하면 컴파일러 에러.
사실 자신의 멤버를 변경하지 않는 멤버 함수는 모두 const멤버 함수여야만 합니다.
class Point {
	int x;
	int y;
public:
	Point(int _x = 0, int _y = 0) : x(_x), y(_y) {}
	int GetX() const { //const 함수
		return x;
	}
	int GetY() const { //const 함수
		return y;
	}
	void SetX(int _x) { //비 const함수:멤버 변경
		x = _x;
	}
	void SetY(int _y) { //비 const함수:멤버 변경
		y = _y;
	}
	void Print() const { //const 함수
		 const << x << ", " << y << endl;
	}
};
int main(){
	const Point p1(0, 0); //const 객체:모든 멤버 변경 불가
	Point p2(2, 3); //비 const객체
	p1.Print();
	p2.Print();
	cout << "p1: " << p1.GetX() << ", " << p1.GetY() << endl;
	cout << "p2: " << p2.GetX() << ", " << p2.GetY() << endl;
	p1.SetX(5); //에러. const객체는 const멤버 함수만 호출가능
	p1.SetY(5); //에러. const객체는 const멤버 함수만 호출가능
	p2.SetX(5);
	p2.SetY(5);
	return 0;
}
두 멤버 함수는 비 const멤버 함수 이므로 const 객체 p1은 비 const멤버 함수를 호출할 수 없습니다.

03 단항 연산자 오버로딩
!, &, ~, *, +, ++, 형변환 연산자 등

++연산자 오버로딩
전위++연산자와 후위++연산자가 있으며 컴파일러와 약속된 함수는 operator++(), operator++(int)입니다.
1_7.cpp ++연산자 정의
++연산자를 구분하기 위해 후위++연산자는 operator++()멤버 함수 호출 시 의미없는(dummy)정수형 인자 0을 전달합니다.
1_8.cpp ++연산자 오버로딩 완성

--연산자 오버로딩
1_9.cpp --연산자 오버로딩

04 이항 연산자 오버로딩
+, -, ==, !=, <= 등

==연산자 오버로딩
==연산자도 의미만 다를 뿐 +연산자와 비슷하게 오버로딩합니다.
==연산자는 비교 연산으로 true혹은 false로 결과가 반환되는 bool타입.
1_10.cpp ==연산자 중복
p1은 this객체이며 p2는 arg객체입니다.

!=연산자 오버로딩
!=는 ==연산자의 부정.
1_11.cpp !=연산자 오버로딩

05 전역 함수를 이용한 연산자 오버로딩
연산자 오버로딩은 두가지가 있다.
1)멤버 함수를 이용한 연산자 오버로딩
2)전역 함수를 이용한 연산자 오버로딩
일반적으로 멤버 함수를 이용한 연산자 오버로딩을 사용합니다.
멤버 함수를 이용한 연산자 오버로딩을 할 수 없을 때 전역 함수 연산자 오버로딩을 사용합니다.
예를 들어 연산자 오버로딩은 컴파일러가 p1 == p2;와 같은 코드를 두 가지로 해석합니다.
1)멤버 함수로 p1.operator==(p2);처럼 해석하며, p1의 operator==()멤버 함수를 호출해 p2를 인자로 전달.
2)전역 함수로 operator == (p1, p2);처럼 해석하며, 전역함수 operator==()의 인자로 p1와 p2객체를 각각 전달.

멤버 함수를 이용한 연산자 오버로딩을 할 수 없는 경우
이항 연산의 왼쪽 항이 연산자 오버로딩 객체가 아니면 멤버 함수를 이용한 연산자 오버로딩을 이용할 수 없습니다.
이항 연산의 왼쪽 객체를 기준으로 연산자 오버로딩 멤버 함수를 호출하기 때문입니다.
class Point {
};
int main() {
	Point pt1(1, 2);
	k + pt1; //여기서 k는 연산자 오버로딩 객체가 아니므로 k.operator+(pt1)처럼 호출할 수 없다.
	         //operator+(k, pt1)처럼 호출해야 합니다.
	return 0;
}
여기서 k + pt1연산은 왼쪽 객체 k가 연산자 오버로딩 객체가 아니므로 전역 함수 연산자 오버로딩을 사용해야 합니다.

멤버 함수를 이용한 연산자 오버로딩
1_12.cpp 멤버 함수 연산자 오버로딩(-연산자)
p1 - p2는 p1의 멤버함수 p1.operator-(p2)를 호출합니다. p2는 인자로 전달됩니다.

전역 함수를 이용한 연산자 오버로딩
1_13.cpp 전역 함수 연산자 오버로딩(-연산자)
p1 - p2는 전역함수 operator-(p1,p2)를 호출합니다. p1과 p2는 인자로 전달됩니다.
멤버함수에선 p1은 thix, p2는 arg였지만
전역함수에선 p1은 argL, p2는 argR.
전역 함수를 이용하면 Point클래스의 private멤버인 x,y에 접근할 수 없으므로 getter를 이용하거나 프렌드함수이용.
friend const Point operator-(const Point& argL, const Point& argR);
const Point operator-(const Point& argL, const Point& argR) {
	return Point(argL.x - argR.x, argL.y - argR.y);
}
이렇게 게터나 세터를 사용하지 않고, x,y에 직접 접근할 수 있습니다.
프렌드함수는 캡슐화를 저해하므로 가능하면 게터,세터를 사용하는 방법이 좋습니다.

프렌드(friend)
프렌드에는 함수 프렌드와 클래스 프렌드, 두 가지가 있습니다.
함수나 클래스를 프렌드로 지정하면 모든 클래스 멤버를 접근 제한 없이 사용할 수 있습니다.
class A {
	friend void Func();
};
void Func() {
	//class A의 모든 멤버를 접근 제한 없이 사용할 수 있습니다.
}
클래스 프렌드는 다음과 같이 지정합니다.
class A {
	friend class B;
}
class B {
	//class A의 모든 멤버를 접근 제한 없이 사용할 수 있습니다.
}

06 STL에 필요한 주요 연산자 오버로딩
함수 호출 연산자 오버로딩(()연산자)
함수 호출 연산자 오버로딩은 객체를 함수처럼 동작하게 하게 연산자.
C++에서 Print(10)이라는 함수 호출 문장은 세가지로 해석할 수 있습니다.
1)함수 호출:Print가 함수 이름입니다.
2)함수 포인터:Print가 함수 포인터입니다.
3)함수 객체:Print가 함수 객체입니다.
함수 호출 연산자를 정의한 객체를 함수 객체라고 합니다.
1_14.cpp 함수, 함수포인터, 함수 객체를 이용한 정수 출력
Print3는 FuncObject클래스의 객체이며 함수처럼 동작합니다.

struct, class 키워드
C++의 struct키워드는 class키워드와 같습니다.
유일하게 다른 점은 멤버 접근 한정자를 지정하지 않으면 struct는 public이 기본 속성이 되고,
class는 private이 기본 속성이 됩니다.

여러 인자를 받는 함수 호출 연산자를 중복한 예제
1_15.cpp 몇 가지 함수 호출 연산자 오버로딩

임시객체
FuncObject()처럼 클래스 이름으로 임시 객체를 생성할 수 있습니다.
임시 객체는 그 문장에서 생성되고 그 문장을 벗어나면 소멸됩니다.
그 문장에서만 임시로 필요한 객체에 사용합니다.

배열 인덱스 연산자 오버로딩([]연산자)
[]연산자 오버로딩은 일반적으로 많은 객체를 저장하고 관리하는 객체에 사용됩니다.
1_16.cpp Point의 []연산자 중복
pt[0]은 pt.operator[](0)을 호출해 pt.x 값을 반환받습니다.
[]연산자 오버로딩은 일반적으로 컨테이너 객체에 사용됩니다.
컨테이너 객체가 관리하는 내부 원소에 접근할 때 사용됩니다.
1_17.cpp 정수를 저장하는 간단한 Array 클래스
ar[i]는 ar.operator[](i)를 호출해 ar객체의 i번째 원소 객체를 반환받습니다.
[]연산자 오버로딩은 쓰기 연산도 가능해야 하므로 operator[]()함수는 const와 비const함수 모두를 제공해야한다.
1_18.cpp 상수 객체를 반환하는 []연산자 오버로딩
operator[](int)함수는 읽기, 쓰기 연산이 모두 가능한 비 const객체(ar)에 사용되며
oeprator[](int) const함수는 읽기 연산만 가능한 const 객체(ar2)에 사용됩니다.

메모리 접근, 클래스 멤버 접근 연산자 오버로딩(*, ->연산자)
*,->연산자는 스마트 포인터나 반복자(iterator)등의 특수한 객체에 사용됩니다.
반복자가 STL의 핵심 구성 요소이므로 *,-> 연산자 오버로딩은 아주 중요합니다.
스마트 포인터는 일반 포인터의 기능에 몇 가지 유용한 기능을 추가한 포인터처럼 동작하는 객체입니다.
일반 포인터를 사용하여 Point클래스의 멤버 함수를 호출하는 예제.
1_19.cpp Point클래스의 일반 포인터 사용
이렇게 일반 포인터를 사용하면 new 연산 후 delete연산을 호출하지 않으면 메모리 누수가 발생하여
프로그램에 심각한 문제가 됩니다.
또한, 사용 중에 함수가 종료하거나 예외 등이 발생하면 동적으로 할당한 메모리를 해제하지 못하는 문제가 발생.
이런 문제들은 스마트 포인터를 사용하여 쉽게 해결할 수 있습니다.
일반 포인터 p1,p2는 가리키는 동적 객체를 delete연산으로 직접 제거해야 합니다.
이제 PointPtr클래스의 소멸자를 이용해 동적으로 할당된 Point객체(heap객체)를 자동으로 제거합시다.
1_20.cpp 스마트 포인터 PointPtr 클래스 생성
이렇게 PointPtr클래스를 만들어 놓으면 동적으로 생성한 Point객체를 소멸자에서 자동으로 삭제하므로
프로그램 중에 예외가 발생하거나 delete 호출을 빼먹어 발생하는 동적메모리 누수 현상을 방지할 수 있다.
p1,p2는 스택객체이므로 main()함수 블록에서 제거되며 p1,p2의 소멸자에서 ptr이 가리키는
동적 메모리 객체를 제거합니다.
p1과 p2가 일반 포인터처럼 동작하려면 p1,p2로 Point클래스에 정의된 멤버 함수를 사용할 수 있어야 합니다.
p1,p2로 Point클래스의 멤버를 접근할 수 있도록 ->연산자를 오버로딩해야 합니다.
1_21.cpp ->연산자 오버로딩
p1->Print()는 p1.operator->()함수를 호출해 p1 내부에 보관된 실제 포인터를 반환받고
이 포인터를 이용해 실제 Point의 멤버 함수(p1.operator->()->Print())를 호출합니다.
일반 포인터의 *연산자는 포인터가 가리키는 객체 자체이므로 스마트 포인터에도 *연산이 가능하도록 연산자 오버로딩.
1_22.cpp *연산자 오버로딩
p1은 일반 포인터로 *p1객체 자체이므로 (*p1).Print()와 같이 멤버 함수를 호출합니다.
p2는 스마트 포인터로 *p2연산이 객체를 반환하게 p2.operator*()를 호출하고 객체를 참조받아
p1.operator*().Print()처럼 함수를 호출합니다.

07 타입 변환 연산자 오버로딩
사용자가 직접 정의해서 사용할 수 있는 타입 변환은 두가지
1)생성자를 이용한 타입변환
2)타입 변환 연산자 오버로딩을 이용한 타입 변환

생성자를 이용한 타입 변환
특정 타입을 인자로 받는 생성자가 있다면 생성자 호출을 통한 타입 변환(객체 생성 후 대입)이 가능합니다.
생성자를 이용해 다른 타입을 자신의 타입으로 변환할 수 있습니다.
1_23.cpp 생성자를 이용한 타입 변환
b = a에서 컴파일러는 A타입의 객체를 B타입으로 변환하기 위해 생성자를 확인합니다.
A타입의 객체(a)를 인자로 받는 생성자가 있으므로 이 생성자를 호출해 B타입의 객체를 생성합니다.
Point객체에 정수를 대입해서 컴파일 할 수 있습니다. 정수를 인자로 받는 생성자가 있기 때문.
1_24.cpp Point클래스의 생성자
pt = 10에서 정수를 인자로 받는 생성자가 있으므로 컴파일러는 Point(10,0)을 호출해 Point객체를 생성합니다.
이렇게 하면 실수로 Point객체에 정수를 대입해도 컴파일이 성공하여 버그로 연결.
그래서 생성자를 이용한 형변환을 의도하지 않는다면 생성자는 명시적 호출만 가능하도록 explicit키워드를 지정.
1_25.cpp explicit Point 생성자
explicit생성자는 명시적 호출만 가능하므로 Point(10)과 같이 호출합니다.
암시적인 생성자 형변환을 의도하지 않는 한 "인자를 갖는 생성자는 모두 explicit생성자로 만들자"

타입변환 연산자 오버로딩을 이용한 타입변환
타입변환 연산자 오버로딩을 사용하면 자신의 타입을 다른 타입으로 변환할 수 있습니다.
1_26.cpp 타입변환 연산자 오버로딩
a = b에서 컴파일러는 B타입 객체(b)를 A타입으로 변화하기 위해 타입변환 연산자 b.operator A()멤버 함수를 호출.
주의할 점은 타입 변환 연산자는 생성자나 소멸자처럼 반환타입을 지정하지 않습니다.
Point클래스 타입을 정수 타입으로 변환할 수 있게 타입 변환 연산자를 오버로딩합시다.
1_27.cpp Point클래스의 int타입 변환 연산자
n = pt는 pt.operator int() const멤버 함수를 호출해 pt의 x값을 반환합니다.
const객체나 비 const객체 모두 타입 변환이 가능하게 const멤버 함수로 정의합니다.

*/

/*
템플릿은 STL 제너릭 프로그래밍의 핵심.
템플릿은 컴파일 타임에 클라이언트가 여러 타입의 함수나 클래스를 쉽게 생성하게 합니다.
서버 코드 작성자는 좀 더 일반적인 프로그램 코드를 만들고 클라이언트가 구체적인 코드를 작성함으로써
제너릭한 프로그래밍이 가능해집니다.

01 함수 템플릿
템플릿은 함수 템플릿(Function Template)과 클래스 템플릿(Class Template)가 있습니다.
함수 템플릿은 함수를 만들어내는 틀이며, 클래스 템플릿은 클래스를 만들어내는 틀.
함수 템플릿:여러 함수를 만들어내는 함수의 틀.
클래스 템플릿:여러 클래스를 만들어내는 클래스의 틀.
4_1.cpp 두 정수 출력
여기에 실수와 문자열을 출력하는 두 함수를 추가하는데 함수 오버로딩을 이용해보자
4_2.cpp 정수, 실수, 문자열 출력 오버로딩 함수
함수 오버로딩을 이용하면 매개변수 리스트가 다른 세 함수를 정의할 수 있습니다.
하지만, 함수 오버로딩은 클라이언트가 매개변수 타입을 미리 알고 있다는 전제로 만들어집니다.
만일 클라이언트에서 타입을 결정해야 한다면 어떤 타입을 사용해 서버코드를 호출할지 몰라 함수 오버로딩 불가능.
템플릿을 이용하면 간단하게 해결할 수 있습니다.
템플릿 함수를 사용하면 컴파일러는 클라이언트의 함수 호출 인자타입을 보고 템플릿 함수의 매개변수 타입을
결정하여 실제 함수인 템플릿 인스턴스 함수를 만들어 냅니다.
서버 함수는 일반화된 기능만을 제공하고 클라이언트가 함수의 매개변수 타입을 결정합니다.
클라이언트가 타입이 다른 함수를 얼마든지 만들어내므로 대단한 확장성.
함수 템플릿은 함수 앞에 template<T>키워드를 붙이면 됩니다.
또한, 클라이언트가 매개변수 타입을 결정하도록 타입을 일반화(T타입)하면 됩니다.
4_3.cpp 함수 템플릿
함수 템플릿 정의는 함수 앞에 template<typename T>라는 키워드를 붙입니다.
T는 템플릿 매개변수이며 클라이언트에서 결정합니다.
template<typename T> Print<T>()으로 실제 함수 세 개를 만들어 냅니다.
Print<int>(), Print<double>(), Print<const char*>()가 만들어지고 위 함수 템플릿의 인스턴스라고 합니다.
함수 템플릿 인스턴스는 컴파일러가 생성한 함수 정의 코드.
클라이언트가 직접 타입을 지정하고 명시적으로 함수를 호출할 수 있습니다.
4_4.cpp 함수 템플릿의 명시적 타입 지정 후 호출
컴파일이 완료되면 함수 템플릿은 존재하지 않으며 인스턴스화된 세 함수가 있을 뿐.
템플릿도 함수처럼 여러 매개변수를 가질 수 있습니다.
4_5.cpp 두 개의 매개변수를 갖는 함수 템플릿.

class와 typename
템플릿을 지정할 때 template<typename T>를 template<class T>로 사용할 수 있습니다.
현재 대부분의 컴파일러에서 두 형식을 모두 지원.
template<class T>형식은 C++표준화 이전부터 사용하던 형식.
표준화 이후에는 template<typename T>가 사용되지만, 호환성을 위해 대부분 컴파일러는 모두 지원.

4_6.cpp Swap() 템플릿 함수
템플릿 함수 정의의 연산이 가능한 객체, 인터페이스를 지원하는 객체라면 모두 매개변수 타입 가능.
T temp = a에서 복사 생성자를 호출하므로 복사 생성자(인터페이스)를 지원해야 하며
a = b나 b = temp에서 대입 연산자를 호출하므로 대입 연산자(인터페이스)를 지원해야 합니다.

4_7.cpp 배열 출력함수 템플릿
함수 템플릿의 매개변수로 타입뿐만 아니라 정수 등도 가능합니다.
하지만 클라이언트 코드에서 PrintArray<int, 5>(arr1)처럼 명시적으로 호출합니다.
함수 인자가 arr1이라는 정보만을 제공하므로 템플릿 매개변수 인자를 컴파일러가 추론할 수 없기 때문.
따라서 명시적으로 호출해 컴파일러가 함수 템플릿 인스턴스를 생성하게 합니다.

템플릿 특수화(Function Template Specialization)는 특수화된 버전의 함수 템플릿을 더 제공하는 것.
4_8.cpp Point 객체를 출력하지 못하는 함수 템플릿 예제
컴파일러가 함수 템플릿의 인스턴스를 만드려면 템플릿의 매개변수 타입 객체인 a가 템플릿 함수 정의의 
연산을 지원해야 합니다.
Point 객체 pt는 cout << 연산이 가능한(인터페이스를 지원하는) 객체여야만 하는데 cout << pt연산이 불가능하므로
컴파일러가 함수 템플릿 인스턴스를 생성하지 못해서 에러가 발생.
첫 번째 해결 방법은 Point클래스에 <<연산자 오버로딩 함수를 추가하는 것.
하지만, 소스코드로 지원되지 않는 라이브러리 상태 등 Point클래스를 수정하지 못하는 상황이라면 불가능.
두 번째 해결 방법은 Point객체만의 특수화된 함수 템플릿을 지원하는 것.
4_9.cpp Point객체만의 함수 템플릿 특수화 지원
Print(n)과 Print(d)는 일반화 버전의 템플릿 함수 인스턴스를 호출하며
Print(pt)는 특수화 버전의 함수 인스턴스를 호출합니다.

02 클래스 템플릿
클래스를 만들어내는 틀(메타 코드).
단지 함수에서 클래스로 바뀌고 함수 템플릿과 비슷하다.
정수형 배열을 추상화한 클래스 Array 예제의 인터페이스는 다음과 같다.
Array(int cap):생성자는 저장 가능한 최대원소의 개수(cap)를 인자로 받아 메모리를 생성합니다.
~Array():소멸자는 생성한 메모리를 제거합니다.
Add(int data):Array 객체에 정수(data)를 추가(저장)합니다.
operator[](int idx):Array객체의 idx 인덱스 원소의 값을 반환합니다.
GetSize():Array객체의 원소 개수를 반환합니다.
4_10.cpp 정수형 Array 클래스
앞으로 STL설명에 자주 언급되는 클래스이다.
정수뿐 아니라 실수를 저장하는 Array객체와 문자열을 저장하는 Array객체가 모두 필요할 때
가장 단순한 방법은 DoubleArray클래스와 StringArray클래스를 직접 정의하는 방법.
4_11.cpp 정수,실수,문자열 Array 클래스 정의
자료형만 다르고 모두 객체가 해야할 일은 모두 같습니다.
또한, Array클래스의 원소 타입을 클라이언트가 결정할 수 없다는 단점.
다른 방법은 클래스 템플릿을 정의하는 것.
클래스 템플릿은 클래스를 정의하기 위한 메타 클래스 코드이며, 템플릿 매개변수 인자를 통해 클라이언트가
클래스에 사용될 타입을 결정할 수 있습니다.
클래스 템플릿은 클래스 앞에 template<T>키워드를 붙이면 됩니다.
또한, 클라이언트가 매개변수 타입을 결정하게 타입을 일반화(T타입)하면 됩니다.
4_12.cpp 클래스 템플릿 Array
클라이언트는 T타입을 int나 double로 결정하여 객체를 생성합니다.
따라서 컴파일러는 Array<int>클래스, Array<double>클래스, Array<string>클래스 세 인스턴스를 생성.
템플릿은 클래스의 메타 코드일 뿐이고 컴파일러는 클래스 템플릿을 이용해 실제 클래스(클래스 정의코드)를 생성.
템플릿의 매개변수도 함수의 매개변수처럼 디폴트 매개변수 값을 지정할 수 있습니다.
Array<> iarr은 디폴트 매개변수 값을 사용하여 Array<int, 100> iarr과 같습니다.
클래스 템플릿도 특수화가 가능합니다.
class Template Specialization은 일반 버전의 템플릿을 사용할 수 없는 경우나 성능 개선이나
특수한 기능 등을 위해 특수화 버전을 별도로 제공하고자 할 때 사용합니다.

클래스 템플릿 특수화를 설명하기 위해 객체의 정보를 출력하는 클래스 템플릿을 생성해보자.
4_14.cpp 객체 정보를 출력하는 ObjectInfo클래스
string의 타입 정보는 조금 길게 출력됩니다.
string도 템플릿 클래스로 typedef되어 있기 떄문.
string타입의 크기는 별의미가 없고 문자열의 길이가 중요함.
클래스 템플릿을 특수화해 string정보만 출력하는 template<> class ObjectInfo<string>클래스를 추가합니다.
일반화 버전:template<typename T> class ObjectInfo
특수화 버전:template<> class ObjectInfo<string>
4_15.cpp ObjectInfo 특수화 버전

03 STL을 위한 템플릿 예제
For_each()는 배열의 원소를 출력하는 함수입니다.
배열의 시작 주소와 끝 주소를 인자로 받아 모든 원소에 대해 클라이언트 함수를 호출합니다.
4_16.cpp For_each() 함수
For_each()함수는 배열의 원소가 정수일 때만 사용가능합니다.
원소의 타입에 상관없이 사용할 수 있는 일반적인 함수라면 클라이언트의 활용도를 높이고 유지보수가 좋아짐.
4_17.cpp 함수 템플릿 For_each()
컴파일러는 클라이언트 코드를 보고 For_each<int*, void(*)(int)>()와 For_each<string*, void(*)(string)>()를 만듦.
4_18.cpp 명시적인 For_each() 호출
PrintInt()와 PrintString()도 템플릿 함수로 작성할 수 있습니다.
4_19.cpp 함수 템플릿 Print()
주의할 점은 출력 함수의 템플릿 매개변수를 컴파일러가 유추할 수 없으므로 명시적으로 매개변수 인자
Print<int>, Print<string>을 지정해야 합니다.
함수 객체를 사용하면 부가적인 서비스를 함수 객체가 제공하게 할 수 있습니다.
4_20.cpp 함수객체(PrintFunctor)를 사용한 For_each()
함수 객체는 부가정보를 가질 수 있으므로 sep이라는 출력 패턴 구분자를 가집니다.

less와 greater를 템플릿으로 작성해보자
4_21.cpp 템플릿 Less, Greater
STL의 less, greater가 표준 어댑터와 동작하도록 단순한 규칙을 가져야 합니다.

템플릿의 매개변수와 함수 객체를 결합하면 변환 타입과 함수 매개변수 타입을 클라이언트가 결정하는
아주 유연한 함수 객체를 만들 수 있습니다.
4_22.cpp 반환 타입과 매개변수 타입을 인자로 갖는 함수 객체
functor1은 void반환 타입과 int 매개변수 타입을 갖는 함수 객체.
functor2는 bool반환 타입과 string 매개변수 타입을 갖는 함수 객체.

STL에서 데이터의 쌍을 표현할 때 항상 사용되는 pair 클래스.
pair클래스는 두 객체를 하나의 객체로 취급할 수 있게 두 객체를 묶어줍니다.
STL의 모든 쌍을 이루는 객체는 pair객체를 사용합니다.
대표적으로 map컨테이너의 key, value의 쌍을 표현할 때나 구간의 시작과 끝을 표현할 때 사용.
4_23.cpp Pair클래스
pair클래스의 주요 멤버는 객체 쌍을 저장하는 first와 second입니다.
        p1    p2    p3    p4
first   10    1     10    1
second  20    "one" 20    "one"

*/